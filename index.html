<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Cartoonify</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        img {
            width: 30em;
        }

        #images {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }

        #input {
            display: flex;
            flex-direction: column;
            align-items: center;

        }

        #buttons {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }

        button {
            margin-top: 3em;
            cursor: pointer;
        }

        #canvas {
            border: 1px solid black;
            /* display: none; */
        }
    </style>
</head>

<body>
    <h1>Image to Cartoon</h1>
    <div id="images">
        <img src="test_bis.png" alt="image" id="image_in" crossorigin="anonymous">
        <img src="test_bis.png" alt="image" id="output" crossorigin="anonymous">
    </div>
    <div id="buttons">
        <button id="upload">Upload</button>
        <button id="download">Download</button>
    </div>

    <canvas id="canvas" width="500" height="500"></canvas>

</body>

<script>

    // run on load:
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    image_in.onload = async () => {
        if (image_in.naturalWidth > image_in.naturalHeight) {
            canvas.width = Math.min(1000, image_in.naturalWidth);
            canvas.height = image_in.naturalHeight * (canvas.width / image_in.naturalWidth);
        } else {
            canvas.height = Math.min(1000, image_in.naturalHeight);
            canvas.width = image_in.naturalWidth * (canvas.height / image_in.naturalHeight);
        }
        await ctx.drawImage(image_in, 0, 0, image_in.naturalWidth, image_in.naturalHeight,
            0, 0, canvas.width, canvas.height)
        low_colors_image = await reduce_colors();
        white_edges_image = await detect_edges();
        black_edges_image = await invert(white_edges_image);
        cartoon_image = await merge(low_colors_image, black_edges_image);
        ctx.putImageData(cartoon_image, 0, 0);
    }

    function hsv2rgb(h, s, v) {
        let f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)];
    }
    function rgb2hsv(r, g, b) {
        let v = Math.max(r, g, b), c = v - Math.min(r, g, b);
        let h = c && ((v == r) ? (g - b) / c : ((v == g) ? 2 + (b - r) / c : 4 + (r - g) / c));
        return [60 * (h < 0 ? h + 6 : h), v && c / v, v];
    }

    async function reduce_colors(n1 = 8, n2 = 4, n3 = 4) {
        var imagedata = await ctx.getImageData(0, 0, canvas.width, canvas.height)
        // imagedata = ctx.getImageData(0, 0, 1, 1)
        let k1 = 360 / n1;
        let k2 = 1 / n2;
        let k3 = 256 / n3;
        for (let i = 0; i < imagedata.data.length; i += 4) {
            let r = imagedata.data[i];
            let g = imagedata.data[i + 1];
            let b = imagedata.data[i + 2];
            let [h, s, v] = rgb2hsv(r, g, b);
            let k = 360 / n1;
            let h2 = k1 * Math.floor(h / k1) + (k1 / 2);
            let s2 = k2 * Math.floor(s / k2) + (k2 / 2);
            let v2 = k3 * Math.floor(v / k3) + (k3 / 2);
            let [r2, g2, b2] = hsv2rgb(h2, s2, v2);
            r2 = Math.floor(r2);
            g2 = Math.floor(g2);
            b2 = Math.floor(b2);
            imagedata.data[i] = r2;
            imagedata.data[i + 1] = g2;
            imagedata.data[i + 2] = b2;
        }
        return imagedata;
    }

    async function convolve(image, kernel) {
        var result = new ImageData(image.width, image.height);
        //   var result = await new ImageData(50, 50);
        var w = image.width;
        var h = image.height;
        var kw = kernel.length;
        var kh = kernel[0].length;
        var rw = (kw - 1) / 2;
        var rh = (kh - 1) / 2;
        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var sum = 0;
                for (var ky = 0; ky < kh; ky++) {
                    for (var kx = 0; kx < kw; kx++) {
                        if (x + kx - rw < 0 || x + kx - rw >= w) continue;
                        if (y + ky - rh < 0 || y + ky - rh >= h) continue;
                        const pos = (y + ky - rh) * w + (x + kx - rw);
                        const val =
                            (image.data[pos * 4] +
                                image.data[pos * 4 + 1] +
                                image.data[pos * 4 + 2]) /
                            3;
                        const kval = kernel[ky][kx];
                        sum += val * kval;
                    }
                }
                sum = Math.floor(sum);
                result.data[(y * w + x) * 4] = sum;
                result.data[(y * w + x) * 4 + 1] = sum;
                result.data[(y * w + x) * 4 + 2] = sum;
                result.data[(y * w + x) * 4 + 3] = 255;
            }
        }
        return result;
    }
    async function detect_edges(k = 1) {
        var imagedata = await ctx.getImageData(0, 0, canvas.width, canvas.height)
        var imagedata_bis;
        if (k == 1) {
            var kernel = [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]];
            imagedata_bis = await convolve(imagedata, kernel);
        }
        else if (k == 2) {
            var kernel = [[-1, -1, -1, -1, -1],
            [-1, 1, 2, 1, -1],
            [-1, 2, 4, 2, -1],
            [-1, 1, 2, 1, -1],
            [-1, -1, -1, -1, -1]];
            imagedata_bis = await convolve(imagedata, kernel);
        }
        return imagedata_bis;
    }
    async function invert(image) {
        for (let i = 0; i < image.data.length; i += 4) {
            image.data[i] = 255 - image.data[i];
            image.data[i + 1] = 255 - image.data[i + 1];
            image.data[i + 2] = 255 - image.data[i + 2];
        }
        return image;
    }
    async function merge(color_image, edges_image) {
        var result = new ImageData(color_image.width, color_image.height);
        for (let i = 0; i < color_image.data.length; i += 4) {
            result.data[i] = Math.min(color_image.data[i], edges_image.data[i]);
            result.data[i + 1] = Math.min(color_image.data[i + 1], edges_image.data[i + 1]);
            result.data[i + 2] = Math.min(color_image.data[i + 2], edges_image.data[i + 2]);
            result.data[i + 3] = 255;
        }
        return result;
    }

</script>

</html>