<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Cartoonify</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        img {
            max-height: 35em;
            max-width: 100%;
        }

        .column {
            width: 40em;
            max-width: 45%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #images {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }

        #input {
            display: flex;
            flex-direction: column;
            align-items: center;

        }

        #buttons {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin: 0.5em;
        }

        #canvas {
            /* border: 1px solid black; */
            display: none;
        }
    </style>
</head>

<body>
    <h1>Image to Cartoon</h1>
    <div id="buttons">
        <input type="file" accept="image/*" name="image" id="file" onchange="uploadFile(event)" style="display: none;">
        <input type="button" value="Upload" onclick="document.getElementById('file').click();" />
        <button id="download" onclick="downloadImage();">Download</button>
    </div>
    <div id="images">
        <div class="column">
            <img src="test_bis.png" alt="input_image" id="image_in" crossorigin="anonymous">
        </div>
        <div class="column">
            <img src="test_bis.png" alt="output_image" id="output" crossorigin="anonymous">
            <fieldset>
                <legend>Output</legend>
                <input type="radio" id="original" name="output_image" onchange="display(original_image);">
                <label for="original">Original</label>
                <input type="radio" id="blured" name="output_image" onchange="display(blured_image);">
                <label for="blured">Blured</label>
                <input type="radio" id="few_colors" name="output_image" onchange="display(low_colors_image);">
                <label for="few_colors">Reduce colors</label>
                <input type="radio" id="grey_scale" name="output_image" onchange="display(greyscale_image);">
                <label for="grey_scale">Greyscale</label>
                <input type="radio" id="edges" name="output_image" onchange="display(black_edges_image);">
                <label for="edges">Edges</label>
                <input type="radio" id="edges_thresholded" name="output_image"
                    onchange="display(black_edges_thresholded_image);">
                <label for="edges_thresholded">Edges Thresholded</label>
                <input type="radio" id="edges_thresholded_eroded" name="output_image"
                    onchange="display(black_edges_thresholded_eroded_image);">
                <label for="edges_thresholded_eroded">Edges Thresholded Eroded</label>
                <input type="radio" id="cartoon" name="output_image" onchange="display(cartoon_image);" checked>
                <label for="cartoon">Cartoon</label>
            </fieldset>
        </div>
    </div>
    <canvas id="canvas" width="500" height="500"></canvas>

</body>

<script>
    var original_image;
    var blured_image;
    var low_colors_image;
    var greyscale_image;
    var white_edges_image;
    var black_edges_image;
    var black_edges_thresholded_image;
    var black_edges_thresholded_eroded_image;
    var cartoon_image;
    function uploadFile(event) {
        image_in.src = URL.createObjectURL(event.target.files[0]);
        full_cartoonify();
    };
    function downloadImage() {
        dataUrl = canvas.toDataURL();
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = 'cartoon.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // run on load
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    image_in.onload = full_cartoonify;
    async function full_cartoonify() {
        // resize image to fit canvas in reasonable size
        if (image_in.naturalWidth > image_in.naturalHeight) {
            canvas.width = Math.min(1000, image_in.naturalWidth);
            canvas.height = image_in.naturalHeight * (canvas.width / image_in.naturalWidth);
        } else {
            canvas.height = Math.min(1000, image_in.naturalHeight);
            canvas.width = image_in.naturalWidth * (canvas.height / image_in.naturalHeight);
        }
        // calculate & display cartoon
        await cartoonify();
        display(cartoon_image);
    }
    function display(image) {
        // draw image on hidden canvas
        ctx.putImageData(image, 0, 0);
        // draw image on visible image element
        dataUrl = canvas.toDataURL();
        image_out = document.getElementById('output');
        image_out.src = dataUrl;
    }

    function hsv2rgb(h, s, v) {
        let f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)];
    }
    function rgb2hsv(r, g, b) {
        let v = Math.max(r, g, b), c = v - Math.min(r, g, b);
        let h = c && ((v == r) ? (g - b) / c : ((v == g) ? 2 + (b - r) / c : 4 + (r - g) / c));
        return [60 * (h < 0 ? h + 6 : h), v && c / v, v];
    }

    async function reduce_colors(image, n1 = 8, n2 = 4, n3 = 4) {
        var result = new ImageData(image.width, image.height);
        let k1 = 360 / n1;
        let k2 = 1 / n2;
        let k3 = 256 / n3;
        for (let i = 0; i < image.data.length; i += 4) {
            let r = image.data[i];
            let g = image.data[i + 1];
            let b = image.data[i + 2];
            let [h, s, v] = rgb2hsv(r, g, b);
            let k = 360 / n1;
            let h2 = k1 * Math.floor(h / k1) + (k1 / 2);
            let s2 = k2 * Math.floor(s / k2) + (k2 / 2);
            let v2 = k3 * Math.floor(v / k3) + (k3 / 2);
            let [r2, g2, b2] = hsv2rgb(h2, s2, v2);
            r2 = Math.floor(r2);
            g2 = Math.floor(g2);
            b2 = Math.floor(b2);
            result.data[i] = r2;
            result.data[i + 1] = g2;
            result.data[i + 2] = b2;
            result.data[i + 3] = 255;
        }
        return result;
    }

    async function convolve(image, kernel) {
        var result = new ImageData(image.width, image.height);
        var w = image.width;
        var h = image.height;
        var kw = kernel.length;
        var kh = kernel[0].length;
        var rw = (kw - 1) / 2;
        var rh = (kh - 1) / 2;
        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var sum = 0;
                for (var ky = 0; ky < kh; ky++) {
                    for (var kx = 0; kx < kw; kx++) {
                        if (x + kx - rw < 0 || x + kx - rw >= w) continue;
                        if (y + ky - rh < 0 || y + ky - rh >= h) continue;
                        const pos = (y + ky - rh) * w + (x + kx - rw);
                        const val = image.data[pos * 4];
                        const kval = kernel[ky][kx];
                        sum += val * kval;
                    }
                }
                sum = Math.floor(sum);
                result.data[(y * w + x) * 4] = sum;
                result.data[(y * w + x) * 4 + 1] = sum;
                result.data[(y * w + x) * 4 + 2] = sum;
                result.data[(y * w + x) * 4 + 3] = 255;
            }
        }
        return result;
    }
    async function convolve3(image, kernel) {
        var result = new ImageData(image.width, image.height);
        var w = image.width;
        var h = image.height;
        var kw = kernel.length;
        var kh = kernel[0].length;
        var rw = Math.floor((kw - 1) / 2);
        var rh = Math.floor((kh - 1) / 2);
        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var sum1 = 0;
                var sum2 = 0;
                var sum3 = 0;
                for (var ky = 0; ky < kh; ky++) {
                    for (var kx = 0; kx < kw; kx++) {
                        if (x + kx - rw < 0 || x + kx - rw >= w) continue;
                        if (y + ky - rh < 0 || y + ky - rh >= h) continue;
                        const pos = (y + ky - rh) * w + (x + kx - rw);
                        const val1 = image.data[pos * 4];
                        const val2 = image.data[pos * 4 + 1];
                        const val3 = image.data[pos * 4 + 2];
                        const kval = kernel[ky][kx];
                        sum1 += val1 * kval;
                        sum2 += val2 * kval;
                        sum3 += val3 * kval;
                    }
                }
                sum1 = Math.floor(sum1);
                sum2 = Math.floor(sum2);
                sum3 = Math.floor(sum3);
                result.data[(y * w + x) * 4] = sum1
                result.data[(y * w + x) * 4 + 1] = sum2;
                result.data[(y * w + x) * 4 + 2] = sum3;
                result.data[(y * w + x) * 4 + 3] = 255;
            }
        }
        return result;
    }
    async function greyscale(image) {
        var result = new ImageData(image.width, image.height);
        var w = image.width;
        var h = image.height;
        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                const pos = y * w + x;
                const val = (image.data[pos * 4] + image.data[pos * 4 + 1] + image.data[pos * 4 + 2]) / 3;
                result.data[(y * w + x) * 4] = val;
                result.data[(y * w + x) * 4 + 1] = val;
                result.data[(y * w + x) * 4 + 2] = val;
                result.data[(y * w + x) * 4 + 3] = 255;
            }
        }
        return result;
    }
    async function dilation(image, kernel, threshold = -1) {
        var result = new ImageData(image.width, image.height);
        var w = image.width;
        var h = image.height;
        var kw = kernel.length;
        var kh = kernel[0].length;
        var rw = Math.floor((kw - 1) / 2);
        var rh = Math.floor((kh - 1) / 2);
        if (threshold == -1) {
            threshold = Math.floor(kernel.length / 2);
        }
        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var count1 = 0;
                var count0 = 0;
                for (var ky = 0; ky < kh; ky++) {
                    for (var kx = 0; kx < kw; kx++) {
                        if (x + kx - rw < 0 || x + kx - rw >= w) continue;
                        if (y + ky - rh < 0 || y + ky - rh >= h) continue;
                        if (kernel[ky][kx] == 0) continue;
                        const pos = ((y + ky - rh) * w) + (x + kx - rw);
                        const val = image.data[pos * 4];
                        if (val > 128) {
                            count1 += 1;
                        } else {
                            count0 += 1;
                        }
                    }
                }
                const pos = (y * w) + x;
                if (count1 > threshold) {
                    result.data[pos * 4] = 255;
                    result.data[pos * 4 + 1] = 255;
                    result.data[pos * 4 + 2] = 255;
                    result.data[pos * 4 + 3] = 255;
                } else {
                    result.data[pos * 4] = 0;
                    result.data[pos * 4 + 1] = 0;
                    result.data[pos * 4 + 2] = 0;
                    result.data[pos * 4 + 3] = 255;
                }
            }
        }
        return result;
    }
    async function erosion(image, kernel, threshold = -1) {
        var result = new ImageData(image.width, image.height);
        var w = image.width;
        var h = image.height;
        var kw = kernel.length;
        var kh = kernel[0].length;
        var rw = Math.floor((kw - 1) / 2);
        var rh = Math.floor((kh - 1) / 2);
        if (threshold == -1) {
            threshold = Math.floor(kernel.length / 2);
        }
        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var count1 = 0;
                var count0 = 0;
                for (var ky = 0; ky < kh; ky++) {
                    for (var kx = 0; kx < kw; kx++) {
                        if (x + kx - rw < 0 || x + kx - rw >= w) continue;
                        if (y + ky - rh < 0 || y + ky - rh >= h) continue;
                        if (kernel[ky][kx] == 0) continue;
                        const pos = ((y + ky - rh) * w) + (x + kx - rw);
                        const val = image.data[pos * 4];
                        if (val > 128) {
                            count1 += 1;
                        } else {
                            count0 += 1;
                        }
                    }
                }
                const pos = (y * w) + x;
                if (count0 > threshold) {
                    result.data[pos * 4] = 0;
                    result.data[pos * 4 + 1] = 0;
                    result.data[pos * 4 + 2] = 0;
                    result.data[pos * 4 + 3] = 255;
                } else {
                    result.data[pos * 4] = 255;
                    result.data[pos * 4 + 1] = 255;
                    result.data[pos * 4 + 2] = 255;
                    result.data[pos * 4 + 3] = 255;
                }
            }
        }
        return result;
    }
    async function detect_edges(image, k = 1) {
        if (k == 0) {
            var kernel = [[0, -1, 0], [-1, 4, -1], [0, -1, 0]];
            return await convolve(image, kernel);
        }
        if (k == 1) {
            var kernel = [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]];
            return await convolve(image, kernel);
        }
        else if (k == 2) {
            var kernel = [[-1, -1, -1, -1, -1],
            [-1, 1, 2, 1, -1],
            [-1, 2, 4, 2, -1],
            [-1, 1, 2, 1, -1],
            [-1, -1, -1, -1, -1]];
            return await convolve(image, kernel);
        }
    }
    async function invert(image) {
        var result = new ImageData(image.width, image.height);
        for (let i = 0; i < image.data.length; i += 4) {
            result.data[i] = 255 - image.data[i];
            result.data[i + 1] = 255 - image.data[i + 1];
            result.data[i + 2] = 255 - image.data[i + 2];
            result.data[i + 3] = 255;
        }
        return result;
    }
    async function absolute_threshold(image, threshold = 128, low = 0, high = 255) {
        var result = new ImageData(image.width, image.height);
        for (let i = 0; i < image.data.length; i += 4) {
            if (image.data[i] > threshold) {
                result.data[i] = high;
                result.data[i + 1] = high;
                result.data[i + 2] = high;
            }
            else {
                result.data[i] = low;
                result.data[i + 1] = low;
                result.data[i + 2] = low;
            }
        }
        return result;
    }
    async function adaptive_threshold(image, kernel_size, C = 128, low = 0, high = 255) {
        var result = new ImageData(image.width, image.height);
        var w = image.width;
        var h = image.height;
        var kernel_offset = Math.floor((kernel_size - 1) / 2);
        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var sum = 0;
                var count = 0;
                for (var ky = 0; ky < kernel_size; ky++) {
                    for (var kx = 0; kx < kernel_size; kx++) {
                        if (x + kx - kernel_offset < 0 || x + kx - kernel_offset >= w) continue;
                        if (y + ky - kernel_offset < 0 || y + ky - kernel_offset >= h) continue;
                        const pos = ((y + ky - kernel_offset) * w) + (x + kx - kernel_offset);
                        const val = image.data[pos * 4];
                        sum += val;
                        count += 1;
                    }
                }
                const pos = (y * w) + x;
                const val = image.data[pos * 4];
                if (val > (sum / count) - C) {
                    result.data[pos * 4] = high;
                    result.data[pos * 4 + 1] = high;
                    result.data[pos * 4 + 2] = high;
                    result.data[pos * 4 + 3] = 255;
                } else {
                    result.data[pos * 4] = low;
                    result.data[pos * 4 + 1] = low;
                    result.data[pos * 4 + 2] = low;
                    result.data[pos * 4 + 3] = 255;
                }
            }
        }
        return result;
    }
    function circle_kernel(r = 1) {
        var kernel = [];
        for (let i = -r; i <= r; i++) {
            kernel[i + r] = [];
            for (let j = -r; j <= r; j++) {
                if ((i * i) + (j * j) <= r) {
                    kernel[i + r][j + r] = 1
                } else {
                    kernel[i + r][j + r] = 0
                }
            }
        }
        return kernel;
    }
    async function gaussian_kernel(s = 5) {
        var kernel = [];
        var sum = 0;
        for (let i = 0; i < s; i++) {
            kernel[i] = [];
            for (let j = 0; j < s; j++) {
                kernel[i][j] = Math.exp(-(Math.pow(i - Math.floor(s / 2), 2) + Math.pow(j - Math.floor(s / 2), 2)));
                sum += kernel[i][j];
            }
        }
        for (let i = 0; i < s; i++) {
            for (let j = 0; j < s; j++) {
                kernel[i][j] /= sum;
            }
        }
        return kernel;
    }
    async function blur(image, s = 3) {
        var kernel = await gaussian_kernel(s);
        return await convolve(image, kernel);
    }
    async function blur3(image, s = 3) {
        var kernel = await gaussian_kernel(s);
        return await convolve3(image, kernel);
    }
    async function merge(image1, image2) {
        var result = new ImageData(image1.width, image1.height);
        for (let i = 0; i < image1.data.length; i += 4) {
            result.data[i] = Math.min(image1.data[i], image2.data[i]);
            result.data[i + 1] = Math.min(image1.data[i + 1], image2.data[i + 1]);
            result.data[i + 2] = Math.min(image1.data[i + 2], image2.data[i + 2]);
            result.data[i + 3] = 255;
        }
        return result;
    }
    async function cartoonify() {
        await ctx.drawImage(image_in, 0, 0, image_in.naturalWidth, image_in.naturalHeight,
            0, 0, canvas.width, canvas.height)
        original_image = await ctx.getImageData(0, 0, canvas.width, canvas.height)
        // fewer colors
        blured_image = await blur3(original_image, Math.floor(original_image.width / 100));
        low_colors_image = await reduce_colors(blured_image);
        // edges
        greyscale_image = await greyscale(original_image);
        white_edges_image = await detect_edges(greyscale_image);
        black_edges_image = await invert(white_edges_image);
        // black_edges_thresholded_image = await absolute_threshold(black_edges_image, 128);
        black_edges_thresholded_image = await adaptive_threshold(black_edges_image, Math.floor(original_image.width / 100));
        black_edges_thresholded_eroded_image = await erosion(black_edges_thresholded_image, circle_kernel(1));
        // merge
        cartoon_image = await merge(low_colors_image, black_edges_thresholded_eroded_image);
        return cartoon_image;
    }

</script>

</html>